Helpers
	firstnum = ['1'..'9'];
	number 	 = ['0'..'9'];
	letter   = (['a'..'z']|['A'..'Z']);

Tokens
	// Datatypes
	integer		= 'integer';
	boolean		= 'boolean';
	var			= 'var';
	number 		= (firstnum number*)|'0';

	// Commands
	assign	= ':=';
	begin 	= 'begin';
	programend 	= 'end.';
	end 	= 'end';
	program	= 'program';
	if		= 'if';
	then	= 'then';
	else	= 'else';
	while	= 'while';
	do		= 'do';
	writeln	= 'writeln';
	break 	= 'break';

	// Operator
	l_par	= '(';
	r_par	= ')';
	plus 	= '+';
	minus 	= '-';
	mult	= '*';
	div 	= 'div';
	mod 	= 'mod';
	eq		= '=';
	lt		= '<';
	gt 		= '>';
	le		= '<=';
	ge		= '>=';
	ne		= '<>';
	and		= 'and';
	or		= 'or';
	xor 	= 'xor';
	not 	= 'not';
	true	= 'true';
	false	= 'false';

	// Other
	colon 		= ':';
	semikolon	= ';';
	dot 		= '.';
	whitespace	= (' '| 10 | 13)+;
	identifier	= letter+number*letter*;

Ignored Tokens
	whitespace;

Productions
	start = 
		   program identifier semikolon body programend;
	body = 
		   {with_dec} declarations begin instructions 
		 | {without_dec} begin instructions
		 | {without_instructions} declarations begin;

	instructions = 
		   {ops} operation
		 | {mult_instructions} instructions semikolon operation
		 | {nested} begin instructions end
		 | [left]:instructions semikolon begin [right]:instructions end;

	operation = 
		   {if} ifexpr
		 | {while} while boolcomp do instructions
		 | {assign} assignment
		 | {print} print
		 | break;

	print =
		   writeln l_par expr r_par;

	assignment = 
		   identifier assign expr;

	declarations =
		   {single} var identifier colon type semikolon
		 | {multi} declarations var identifier colon type semikolon;

	type = 
		   {boolean} boolean
		 | {integer} integer;
	
	expr =
		   {boolcomp} boolcomp
		 | {arithexpr} arithexpr;

	arithexpr =
		   {plus} arithexpr plus factor 
		 | {minus} arithexpr minus factor
		 | factor;

	factor =
		   {mod} factor mod term
		 | {mult} factor mult term
		 | {div} factor div term
		 | term;

	term = 
		   {number} number
		 | {identifier} identifier;

	comparision = 
		   {gt} gt
		 | {ge} ge
		 | {lt} lt
		 | {le} le
		 | {ne} ne
		 | {eq} eq;

	// While and nested instructions, nested by begin and end
	whileinstructions = 
		   {first} operation
		 | begin instructions end; 


	// Booleans and their precedences
	boolcomp = 
		   {eq} boolcomp eq boolexpr
		 | {ne} boolcomp ne boolexpr
		 | {comparision} [left]:arithexpr comparision [right]:arithexpr
		 | boolexpr;

	boolexpr = 
		   {or} boolexpr or boolterm
		 | {xor} boolexpr xor boolterm
		 | boolterm;

	boolterm =
		   {and} boolterm and boolfactor
		 | boolfactor;

	boolfactor =
		   {not} not boolfactor
		 | {true} true
		 | {false} false
		 | identifier;
	/**
	 * If Expressions
	 */
	ifexpr = 
		   {matched} matchedstmt
		 | {openstmt} openstmt;

	matchedstmt = 
		   {matched} if boolcomp then [left]:matchedstmt else [right]:matchedstmt
		 | instructions;

	openstmt =
		   {open} if boolcomp then ifexpr
		 | {matched} if boolcomp then matchedstmt else openstmt;